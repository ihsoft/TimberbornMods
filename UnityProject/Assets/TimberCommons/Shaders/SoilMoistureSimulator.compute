// Shader that simulates soil moisture.

// Common functions.
#define MAX4(v1, v2, v3, v4) max(max(v1, v2), max(v3, v4))
#define MAX8(v1, v2, v3, v4, v5, v6, v7, v8) max(MAX4(v1, v2, v3, v4), MAX4(v5, v6, v7, v8))
#define CoordinatesToIndex(coordinates) ((coordinates.y + 1) * Stride + coordinates.x + 1)
#define IndexToCoordinates(index) int2((index % Stride) - 1, (index / Stride) - 1)

// Constants. Set the values only once.
uint Stride;
float MinLevelChange;

// SoilMoistureSimulationSettings
float ConstantQuadraticCoefficient;
float LinearQuadraticCoefficient;
int MaxClusterSaturation;
float MinimumWaterContamination;
float QuadraticEvaporationCoefficient;
int VerticalSpreadCostMultiplier;
float WaterContaminationScaler;

// Persistent shader state.
// FIXME: Make it!

// INPUT: Update on every dispatch.
StructuredBuffer<float> ContaminationBuff;
StructuredBuffer<float> WaterDepthBuff;
StructuredBuffer<int> AboveMoistureBarriersBuff; //bool
StructuredBuffer<int> FullMoistureBarriersBuff; //bool
StructuredBuffer<int> CeiledWaterHeightBuff;
StructuredBuffer<int> UnsafeCellHeightBuff;

#define AboveMoistureBarriers(index) AboveMoistureBarriersBuff[index]
#define CeiledWaterHeight(index) CeiledWaterHeightBuff[index]
#define Contamination(index) ContaminationBuff[index]
#define FullMoistureBarriers(index) FullMoistureBarriersBuff[index]
#define UnsafeCellHeight(index) UnsafeCellHeightBuff[index]
#define WaterDepth(index) WaterDepthBuff[index]

// OUTPUT: fetch on every dispatch.
RWStructuredBuffer<float> MoistureLevelsBuff;
RWStructuredBuffer<float> WaterEvaporationModifierBuff;
AppendStructuredBuffer<int> MoistureLevelsChangedLastTickBuff;

#define MoistureLevels(index) MoistureLevelsBuff[index]
#define SetWaterEvaporationModifier(index, value) WaterEvaporationModifierBuff[index] = value

// INTERMEDIATE: Only used between the kernels.
RWStructuredBuffer<float> LastTickMoistureLevelsBuff; 
RWStructuredBuffer<float> WateredNeighboursBuff;
RWStructuredBuffer<int> ClusterSaturationBuff;

#define ClusterSaturation(index) ClusterSaturationBuff[index]
#define LastTickMoistureLevels(index) LastTickMoistureLevelsBuff[index]
#define WateredNeighbours(index) WateredNeighboursBuff[index]

// Execution chain:
// SavePreviousState999(in MoistureLevels, out LastTickMoistureLevels)
// CountWateredNeighbors(in LastTickMoistureLevels, in WaterDepth, out WateredNeighbours)
// CalculateClusterSaturationAndWaterEvaporation(
//     in WaterDepth, in WateredNeighbours, out ClusterSaturation, out WaterEvaporationModifier)
// CalculateMoisture(in AboveMoistureBarriers, in FullMoistureBarriers, in UnsafeCellHeight, in LastTickMoistureLevels,
//     in WaterDepth, in Contamination, in CeiledWaterHeight, in ClusterSaturation,
//     out MoistureLevels,
// FIXME: why having ceiled water height? UnsafeCellHeight+WaterDepth?
// USe UnsafeCellHeight + Math.Ceil(WaterDepth)

// Forward functions declarations.
float GetUpdatedMoisture(int index);
int MoistureSpreadByWateredCell(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight);
int GetMoistureOfWateredCell(int indexAtOrigin);
float MoistureSpreadByMoistCell(
    int neighborIndex, int neighborTerrainHeight, int originTerrainHeight,
    float spreadCost, bool firstBarrier, bool secondBarrier);
float MoistureSpreadByMoistCell(
    int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost);

#pragma kernel SavePreviousState997

[numthreads(1024, 1, 1)]
void SavePreviousState997(uint3 id : SV_DispatchThreadID)
{
    LastTickMoistureLevels(id.x) = MoistureLevels(id.x);
}

#pragma kernel CountWateredNeighbors

[numthreads(8, 8, 1)]
void CountWateredNeighbors(uint3 id : SV_DispatchThreadID) {
    const uint index = CoordinatesToIndex(id.xy);
    int count = 0;
    if (WaterDepth(index) > 0) {
        count++;
        int num = index - Stride;
        int num2 = index - Stride - 1;
        int num3 = index - 1;
        int num4 = index + Stride - 1;
        int num5 = index + Stride;
        int num6 = index + Stride + 1;
        int num7 = index + 1;
        int num8 = index - Stride + 1;
        count += WaterDepth(num) > 0 ? 1 : 0;
        count += WaterDepth(num2) > 0 ? 1 : 0;
        count += WaterDepth(num3) > 0 ? 1 : 0;
        count += WaterDepth(num4) > 0 ? 1 : 0;
        count += WaterDepth(num5) > 0 ? 1 : 0;
        count += WaterDepth(num6) > 0 ? 1 : 0;
        count += WaterDepth(num7) > 0 ? 1 : 0;
        count += WaterDepth(num8) > 0 ? 1 : 0;
    }
    WateredNeighbours(index) = count;
}

#pragma kernel CalculateClusterSaturationAndWaterEvaporation

[numthreads(8, 8, 1)]
void CalculateClusterSaturationAndWaterEvaporation(uint3 id : SV_DispatchThreadID) {
    const uint index = CoordinatesToIndex(id.xy);
    if (!(WaterDepth(index) > 0)) {
        ClusterSaturation(index) = 0;
        SetWaterEvaporationModifier(index, 1);
        return;
    }
    int num2 = index - Stride;
    int num3 = index - 1;
    int num4 = index + Stride;
    int num5 = index + 1;
    int num6 = WateredNeighbours(index);
    int num7 = WateredNeighbours(num2);
    int num8 = WateredNeighbours(num3);
    int num9 = WateredNeighbours(num4);
    int num10 = WateredNeighbours(num5);
    if (num7 > num6) {
        num6 = num7 - 1;
    }
    if (num8 > num6) {
        num6 = num8 - 1;
    }
    if (num9 > num6) {
        num6 = num9 - 1;
    }
    if (num10 > num6) {
        num6 = num10 - 1;
    }
    ClusterSaturation(index) = num6 > MaxClusterSaturation
        ? MaxClusterSaturation
        : num6;
    int num11 = 10 - num6;
    float modifier = QuadraticEvaporationCoefficient * num11 * num11
        + LinearQuadraticCoefficient * num11
        + ConstantQuadraticCoefficient;
    SetWaterEvaporationModifier(index, modifier);
}

#pragma kernel CalculateMoisture

[numthreads(8, 8, 1)]
void CalculateMoisture(uint3 id : SV_DispatchThreadID)
{
    const uint index = CoordinatesToIndex(id.xy);
    float oldLevel = MoistureLevels(index);
    float newLevel = GetUpdatedMoisture(index);
    if (abs(oldLevel - newLevel) > MinLevelChange)
    {
        MoistureLevels(index) = GetUpdatedMoisture(index);
        MoistureLevelsChangedLastTickBuff.Append(index);
    }
}

float GetUpdatedMoisture(int index)
{
    if (FullMoistureBarriers(index))
    {
        return 0;
    }
    int num = index - Stride;
    int num2 = UnsafeCellHeight(num);
    int num3 = index - Stride - 1;
    int num4 = UnsafeCellHeight(num3);
    int num5 = index - 1;
    int num6 = UnsafeCellHeight(num5);
    int num7 = index + Stride - 1;
    int num8 = UnsafeCellHeight(num7);
    int num9 = index + Stride;
    int num10 = UnsafeCellHeight(num9);
    int num11 = index + Stride + 1;
    int num12 = UnsafeCellHeight(num11);
    int num13 = index + 1;
    int num14 = UnsafeCellHeight(num13);
    int num15 = index - Stride + 1;
    int num16 = UnsafeCellHeight(num15);
    int originTerrainHeight = UnsafeCellHeight(index);
    float num17 = LastTickMoistureLevels(index);
    bool flag = FullMoistureBarriers(num);
    bool flag2 = FullMoistureBarriers(num5);
    bool flag3 = FullMoistureBarriers(num9);
    bool flag4 = FullMoistureBarriers(num13);
    int num18 = MAX4(
        MoistureSpreadByWateredCell(num, num2, originTerrainHeight),
        MoistureSpreadByWateredCell(num5, num6, originTerrainHeight),
        MoistureSpreadByWateredCell(num9, num10, originTerrainHeight),
        MoistureSpreadByWateredCell(num13, num14, originTerrainHeight));
    int num19 = (int)ceil(WaterDepth(num));
    int num20 = (int)ceil(WaterDepth(num3));
    int num21 = (int)ceil(WaterDepth(num5));
    int num22 = (int)ceil(WaterDepth(num7));
    int num23 = (int)ceil(WaterDepth(num9));
    int num24 = (int)ceil(WaterDepth(num11));
    int num25 = (int)ceil(WaterDepth(num13));
    int num26 = (int)ceil(WaterDepth(num15));
    float num27 = MAX8(
        MoistureSpreadByMoistCell(num, num2 + num19, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(num3, num4 + num20, originTerrainHeight, 1.414f, flag, flag2),
        MoistureSpreadByMoistCell(num5, num6 + num21, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(num7, num8 + num22, originTerrainHeight, 1.414f, flag2, flag3),
        MoistureSpreadByMoistCell(num9, num10 + num23, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(num11, num12 + num24, originTerrainHeight, 1.414f, flag3, flag4),
        MoistureSpreadByMoistCell(num13, num14 + num25, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(num15, num16 + num26, originTerrainHeight, 1.414f, flag4, flag));
    float num28 = num17 - 0.5;
    if (num28 < 0)
    {
        num28 = 0;
    }
    float num29 = num28;
    if ((float)num18 > num28 && (float)num18 >= num27)
    {
        float num30 = num17 + 1;
        num29 = (((float)num18 > num30) ? num30 : ((float)num18));
    }
    else if (num27 > num28)
    {
        num29 = num27;
    }
    return num29 * (1 - Contamination(index));
}

int MoistureSpreadByWateredCell(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight)
{
    if (AboveMoistureBarriers(neighborIndex) && neighborTerrainHeight >= originTerrainHeight)
    {
        return 0;
    }
    int num = CeiledWaterHeight(neighborIndex);
    if (num <= 0)
    {
        return 0;
    }
    int moistureOfWateredCell = GetMoistureOfWateredCell(neighborIndex);
    int num2 = originTerrainHeight - num;
    if (num2 < 0)
    {
        num2 = 0;
    }
    return moistureOfWateredCell - num2 * VerticalSpreadCostMultiplier;
}

int GetMoistureOfWateredCell(int indexAtOrigin)
{
    float num = 2 * (float)ClusterSaturation(indexAtOrigin);
    float num2 = Contamination(indexAtOrigin);
    if (num2 < MinimumWaterContamination)
    {
        return (int)num;
    }
    float num3 = num2 * WaterContaminationScaler;
    if (num3 >= 1)
    {
        return 0;
    }
    return (int)(num * (1 - num3));
}

float MoistureSpreadByMoistCell(
    int neighborIndex, int neighborTerrainHeight, int originTerrainHeight,
    float spreadCost, bool firstBarrier, bool secondBarrier)
{
    if (firstBarrier && secondBarrier)
    {
        return 0;
    }
    return MoistureSpreadByMoistCell(neighborIndex, neighborTerrainHeight, originTerrainHeight, spreadCost);
}

float MoistureSpreadByMoistCell(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost)
{
    int num = originTerrainHeight - neighborTerrainHeight;
    if (num < 0)
    {
        num = 0;
    }
    return LastTickMoistureLevels(neighborIndex) - (float)(num * VerticalSpreadCostMultiplier) - spreadCost;
}
