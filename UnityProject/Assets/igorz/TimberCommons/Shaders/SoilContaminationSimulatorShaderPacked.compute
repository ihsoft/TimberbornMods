// Shader that simulates soil contamination.

// Kernels and execution order:
// 1. SavePreviousState
// 2. CalculateContaminationCandidates
// 3. UpdateContaminationsFromCandidates

#pragma kernel SavePreviousState
// IN: ContaminationCandidatesBuff
// OUT: LastTickContaminationCandidatesBuff

#pragma kernel CalculateContaminationCandidates
// IN: LastTickContaminationCandidatesBuff,
//     InputStruct1.UnsafeCellHeights, InputStruct1.BitmapFlags, InputStruct1.WaterDepths,
// OUT: ContaminationCandidatesBuff

#pragma kernel UpdateContaminationsFromCandidates
// IN: ContaminationCandidatesBuff, ContaminationLevelsBuff
// OUT: ContaminationLevelsBuff, ContaminationsChangedLastTickBuff

// Common functions.
#define MAX4(v1, v2, v3, v4) max(max(v1, v2), max(v3, v4))
#define MAX8(v1, v2, v3, v4, v5, v6, v7, v8) max(MAX4(v1, v2, v3, v4), MAX4(v5, v6, v7, v8))
#define CoordinatesToIndex(coordinates) ((coordinates.y + 1) * Stride + coordinates.x + 1)
#define IndexToCoordinates(index) int2((index % Stride) - 1, (index / Stride) - 1)
#define SetBitmapFlag(reference, flag, value) reference.BitmapFlags = value ? reference.BitmapFlags | flag : reference.BitmapFlags & ~flag
#define CheckBitmapFlag(reference, flag) ((reference.BitmapFlags & flag) != 0)

// Constants. Set the values only once.
uint Stride;
float DeltaTime;

float ContaminationDecayRate;
float ContaminationNegativeEqualizationRate;
float ContaminationPositiveEqualizationRate;
float ContaminationScaler;
float ContaminationSpreadingRate;
float DiagonalSpreadCost;
float MinimumSoilContamination;
float MinimumWaterContamination;
float RegularSpreadCost;
float VerticalCostModifier;

// Floating point comparison tolerance.
#define MIN_LEVEL_CHANGE 0.000001

// Persistent shader state.
RWStructuredBuffer<float> ContaminationCandidatesBuff; // Set one time on shader init.

#define ContaminationCandidates(index) ContaminationCandidatesBuff[index]

// INPUT: Update on every dispatch.
// For better performance, pack all data to the aligned structures (128-bit multiples).
struct InputStruct1 {
    float Contaminations;
    float WaterDepths;
    int UnsafeCellHeights;
    uint BitmapFlags;

    static const uint ContaminationBarrierBit = 0x0001;
    static const uint AboveMoistureBarrierBit = 0x0002;
};
StructuredBuffer<InputStruct1> PackedInput1;

#define Contaminations(index) PackedInput1[index].Contaminations
#define UnsafeCellHeights(index) PackedInput1[index].UnsafeCellHeights
#define CeiledWaterHeights(index) ceil(PackedInput1[index].WaterDepths + PackedInput1[index].UnsafeCellHeights)
#define ContaminationBarriers(index) CheckBitmapFlag(PackedInput1[index], InputStruct1::ContaminationBarrierBit)
#define AboveMoistureBarriers(index) CheckBitmapFlag(PackedInput1[index], InputStruct1::AboveMoistureBarrierBit)

// OUTPUT: Read on every dispatch.
RWStructuredBuffer<float> ContaminationLevelsBuff;
AppendStructuredBuffer<int> ContaminationsChangedLastTickBuff;

#define ContaminationLevels(index) ContaminationLevelsBuff[index]
#define AddContaminationsChangedLastTick(index) ContaminationsChangedLastTickBuff.Append(index)

// INTERMEDIATE: Only used between the kernels.
RWStructuredBuffer<float> LastTickContaminationCandidatesBuff;

#define LastTickContaminationCandidates(index) LastTickContaminationCandidatesBuff[index]

// Forward functions declarations.
float GetContaminationCandidate(uint index);
float GetContaminationFromWater(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight);
float GetContaminationFromNeighbor(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost);
float GetContaminationFromNeighbor(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost, bool firstBarrier, bool secondBarrier);

[numthreads(64, 1, 1)]
void SavePreviousState(uint3 id : SV_DispatchThreadID)
{
    LastTickContaminationCandidates(id.x) = ContaminationCandidates(id.x);
}

[numthreads(8, 8, 1)]
void CalculateContaminationCandidates(uint3 id : SV_DispatchThreadID)
{
    const uint index = CoordinatesToIndex(id.xy);
    ContaminationCandidates(index) = GetContaminationCandidate(index);
}

[numthreads(8, 8, 1)]
void UpdateContaminationsFromCandidates(uint3 id : SV_DispatchThreadID)
{
    const uint index = CoordinatesToIndex(id.xy);
    float num2 = ContaminationLevels(index);
    float num3 = ContaminationCandidates(index);
    float num4 = num3 - num2;
    float num5 = ((num4 > 0) ? ContaminationPositiveEqualizationRate : ContaminationNegativeEqualizationRate);
    float num6 = DeltaTime * num5;
    float num7 = ((num4 <= num6 && num4 >= 0 - num6) ? num3 : (num2 + (float)sign(num4) * num6));
    if (num7 < MinimumSoilContamination)
    {
        num7 = 0;
    }
    if (abs(num7 - num2) > MIN_LEVEL_CHANGE)
    {
        ContaminationLevels(index) = num7;
        AddContaminationsChangedLastTick(index);
    }
}

float GetContaminationCandidate(uint index)
{
    if (ContaminationBarriers(index))
    {
        return 0;
    }
    int num = index - Stride;
    int num2 = index - Stride - 1;
    int num3 = index - 1;
    int num4 = index + Stride - 1;
    int num5 = index + Stride;
    int num6 = index + Stride + 1;
    int num7 = index + 1;
    int num8 = index - Stride + 1;
    int neighborTerrainHeight = UnsafeCellHeights(num);
    int neighborTerrainHeight2 = UnsafeCellHeights(num2);
    int neighborTerrainHeight3 = UnsafeCellHeights(num3);
    int neighborTerrainHeight4 = UnsafeCellHeights(num4);
    int neighborTerrainHeight5 = UnsafeCellHeights(num5);
    int neighborTerrainHeight6 = UnsafeCellHeights(num6);
    int neighborTerrainHeight7 = UnsafeCellHeights(num7);
    int neighborTerrainHeight8 = UnsafeCellHeights(num8);
    int originTerrainHeight = UnsafeCellHeights(index);
    bool flag = ContaminationBarriers(num);
    bool flag2 = ContaminationBarriers(num3);
    bool flag3 = ContaminationBarriers(num5);
    bool flag4 = ContaminationBarriers(num7);
    float num9 = MAX4(
        GetContaminationFromWater(num, neighborTerrainHeight, originTerrainHeight),
        GetContaminationFromWater(num3, neighborTerrainHeight3, originTerrainHeight),
        GetContaminationFromWater(num5, neighborTerrainHeight5, originTerrainHeight),
        GetContaminationFromWater(num7, neighborTerrainHeight7, originTerrainHeight));
    float num10 = MAX8(
        GetContaminationFromNeighbor(num, neighborTerrainHeight, originTerrainHeight, RegularSpreadCost),
        GetContaminationFromNeighbor(num2, neighborTerrainHeight2, originTerrainHeight, DiagonalSpreadCost, flag, flag2),
        GetContaminationFromNeighbor(num3, neighborTerrainHeight3, originTerrainHeight, RegularSpreadCost),
        GetContaminationFromNeighbor(num4, neighborTerrainHeight4, originTerrainHeight, DiagonalSpreadCost, flag2, flag3),
        GetContaminationFromNeighbor(num5, neighborTerrainHeight5, originTerrainHeight, RegularSpreadCost),
        GetContaminationFromNeighbor(num6, neighborTerrainHeight6, originTerrainHeight, DiagonalSpreadCost, flag3, flag4),
        GetContaminationFromNeighbor(num7, neighborTerrainHeight7, originTerrainHeight, RegularSpreadCost),
        GetContaminationFromNeighbor(num8, neighborTerrainHeight8, originTerrainHeight, DiagonalSpreadCost, flag4, flag));
    float num11 = LastTickContaminationCandidates(index);
    float num12 = num11 - ContaminationDecayRate;
    if (num12 < 0)
    {
        num12 = 0;
    }
    if (num9 > num12 && num9 >= num10)
    {
        float num13 = num11 + ContaminationSpreadingRate;
        if (!(num9 > num13))
        {
            return num9;
        }
        return num13;
    }
    if (num10 > num12)
    {
        return num10;
    }
    return num12;
}

float GetContaminationFromWater(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight)
{
    if (AboveMoistureBarriers(neighborIndex) && neighborTerrainHeight >= originTerrainHeight)
    {
        return 0;
    }
    int num = CeiledWaterHeights(neighborIndex);
    if (num <= 0)
    {
        return 0;
    }
    float num2 = Contaminations(neighborIndex) - MinimumWaterContamination;
    if (num2 < 0)
    {
        return 0;
    }
    float num3 = num2 * ContaminationScaler;
    int num4 = originTerrainHeight - num;
    if (num4 < 0)
    {
        return num3;
    }
    float num5 = (float)num4 * VerticalCostModifier;
    return num3 - num5;
}

float GetContaminationFromNeighbor(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost)
{
    int num = originTerrainHeight - neighborTerrainHeight;
    if (num < 0)
    {
        num = 0;
    }
    float num2 = (float)num * VerticalCostModifier;
    return LastTickContaminationCandidates(neighborIndex) - num2 - spreadCost;
}

float GetContaminationFromNeighbor(int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost, bool firstBarrier, bool secondBarrier)
{
    if (firstBarrier && secondBarrier)
    {
        return 0;
    }
    return GetContaminationFromNeighbor(neighborIndex, neighborTerrainHeight, originTerrainHeight, spreadCost);
}
