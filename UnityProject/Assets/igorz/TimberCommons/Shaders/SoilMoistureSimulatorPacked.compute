// Shader that simulates soil moisture.

/************************************************************************/
/* Types which this shader operates                                     */
/************************************************************************/
#include "common.hlsl"

// Input only types.
typedef StructuredBuffer<InputStruct1> TPackedInput1;
typedef StructuredBuffer<float> TLastTickMoistureLevelsBuff;
typedef StructuredBuffer<float> TMoistureLevelsBuff;
typedef StructuredBuffer<float> TWateredNeighboursBuff;
typedef StructuredBuffer<int> TClusterSaturationBuff;

// Input/output types.
typedef RWStructuredBuffer<float> TRWLastTickMoistureLevelsBuff;
typedef RWStructuredBuffer<float> TRWMoistureLevelsBuff;
typedef RWStructuredBuffer<float> TRWWaterEvaporationModifierBuff;
typedef RWStructuredBuffer<float> TRWWateredNeighboursBuff;
typedef RWStructuredBuffer<int> TRWClusterSaturationBuff;

// Output only types.
typedef AppendStructuredBuffer<int> TAMoistureLevelsChangedLastTickBuff;

// Kernels and execution order:
// 1. SavePreviousState
// 2. CountWateredNeighbors
// 3. CalculateClusterSaturationAndWaterEvaporation
// 4. CalculateMoisture

#pragma kernel SavePreviousState
// IN: MoistureLevelsBuff
// OUT: LastTickMoistureLevelsBuff

#pragma kernel CountWateredNeighbors
// IN: WaterDepthsBuff
// OUT: WateredNeighboursBuff

#pragma kernel CalculateClusterSaturationAndWaterEvaporation
// IN: WaterDepthsBuff, WateredNeighboursBuff
// OUT: ClusterSaturationBuff, WaterEvaporationModifierBuff

#pragma kernel CalculateMoisture
// IN: InputStruct1 (UnsafeCellHeights, BitmapFlags),
//     WaterDepthsBuff, ContaminationsBuff, LastTickMoistureLevelsBuff, ClusterSaturationBuff,
// OUT: MoistureLevelsChangedLastTickBuff
// RFE: MoistureLevelsBuff

// SoilMoistureSimulationSettings
float ConstantQuadraticCoefficient;
float LinearQuadraticCoefficient;
int MaxClusterSaturation;
float MinimumWaterContamination;
float QuadraticEvaporationCoefficient;
int VerticalSpreadCostMultiplier;
float WaterContaminationScaler;

// DirectSoilMoistureSystemSettings
float WaterTowerIrrigatedLevel;

// Floating point comparison tolerance.
#define MIN_LEVEL_CHANGE 0.0001

// Buffer access abstraction functions.    
#define AppendMoistureLevelsChangedLastTick(index) MoistureLevelsChangedLastTickBuff.Append(index)
#define ClusterSaturation(index) ClusterSaturationBuff[index]
#define LastTickMoistureLevels(index) LastTickMoistureLevelsBuff[index]
#define MoistureLevels(index) MoistureLevelsBuff[index]
#define WaterEvaporationModifier(index) WaterEvaporationModifierBuff[index]
#define WateredNeighbours(index) WateredNeighboursBuff[index]

/************************************************************************/
/* Functions                                                            */
/************************************************************************/
int GetMoistureOfWateredCell(
    TContaminationsBuff ContaminationsBuff,
    TClusterSaturationBuff ClusterSaturationBuff,
    int indexAtOrigin)
{
    float num = 2 * (float)ClusterSaturation(indexAtOrigin);
    float num2 = Contaminations(indexAtOrigin);
    if (num2 < MinimumWaterContamination)
    {
        return (int)num;
    }
    float num3 = num2 * WaterContaminationScaler;
    if (num3 >= 1)
    {
        return 0;
    }
    return (int)(num * (1 - num3));
}

int MoistureSpreadByWateredCell(
    TPackedInput1 PackedInput1,
    TWaterDepthsBuff WaterDepthsBuff,
    TContaminationsBuff ContaminationsBuff,
    TClusterSaturationBuff ClusterSaturationBuff,
    int neighborIndex, int neighborTerrainHeight, int originTerrainHeight)
{
    if (AboveMoistureBarriers(neighborIndex) && neighborTerrainHeight >= originTerrainHeight)
    {
        return 0;
    }
    int num = CeiledWaterHeights(neighborIndex);
    if (num <= 0)
    {
        return 0;
    }
    int moistureOfWateredCell = GetMoistureOfWateredCell(ContaminationsBuff, ClusterSaturationBuff, neighborIndex);
    int num2 = originTerrainHeight - num;
    if (num2 < 0)
    {
        num2 = 0;
    }
    return moistureOfWateredCell - num2 * VerticalSpreadCostMultiplier;
}

float MoistureSpreadByMoistCell(
    TLastTickMoistureLevelsBuff LastTickMoistureLevelsBuff,
    int neighborIndex, int neighborTerrainHeight, int originTerrainHeight, float spreadCost)
{
    int num = originTerrainHeight - neighborTerrainHeight;
    if (num < 0)
    {
        num = 0;
    }
    return LastTickMoistureLevels(neighborIndex) - (float)(num * VerticalSpreadCostMultiplier) - spreadCost;
}

float MoistureSpreadByMoistCell(
    TLastTickMoistureLevelsBuff LastTickMoistureLevelsBuff,
    int neighborIndex, int neighborTerrainHeight, int originTerrainHeight,
    float spreadCost, bool firstBarrier, bool secondBarrier)
{
    if (firstBarrier && secondBarrier)
    {
        return 0;
    }
    return MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, neighborIndex, neighborTerrainHeight, originTerrainHeight, spreadCost);
}

float GetUpdatedMoisture(
    TPackedInput1 PackedInput1,
    TWaterDepthsBuff WaterDepthsBuff,
    TContaminationsBuff ContaminationsBuff,
    TLastTickMoistureLevelsBuff LastTickMoistureLevelsBuff,
    TClusterSaturationBuff ClusterSaturationBuff,
    int index)
{
    if (FullMoistureBarriers(index))
    {
        return 0;
    }
    int num = index - Stride;
    int num2 = UnsafeCellHeights(num);
    int num3 = index - Stride - 1;
    int num4 = UnsafeCellHeights(num3);
    int num5 = index - 1;
    int num6 = UnsafeCellHeights(num5);
    int num7 = index + Stride - 1;
    int num8 = UnsafeCellHeights(num7);
    int num9 = index + Stride;
    int num10 = UnsafeCellHeights(num9);
    int num11 = index + Stride + 1;
    int num12 = UnsafeCellHeights(num11);
    int num13 = index + 1;
    int num14 = UnsafeCellHeights(num13);
    int num15 = index - Stride + 1;
    int num16 = UnsafeCellHeights(num15);
    int originTerrainHeight = UnsafeCellHeights(index);
    float num17 = LastTickMoistureLevels(index);
    bool flag = FullMoistureBarriers(num);
    bool flag2 = FullMoistureBarriers(num5);
    bool flag3 = FullMoistureBarriers(num9);
    bool flag4 = FullMoistureBarriers(num13);
    int num18 = MAX4(
        MoistureSpreadByWateredCell(
            PackedInput1, WaterDepthsBuff, ContaminationsBuff, ClusterSaturationBuff,
            num, num2, originTerrainHeight),
        MoistureSpreadByWateredCell(
            PackedInput1, WaterDepthsBuff, ContaminationsBuff, ClusterSaturationBuff,
            num5, num6, originTerrainHeight),
        MoistureSpreadByWateredCell(
            PackedInput1, WaterDepthsBuff, ContaminationsBuff, ClusterSaturationBuff,
            num9, num10, originTerrainHeight),
        MoistureSpreadByWateredCell(
            PackedInput1, WaterDepthsBuff, ContaminationsBuff, ClusterSaturationBuff,
            num13, num14, originTerrainHeight));
    int num19 = (int)ceil(WaterDepths(num));
    int num20 = (int)ceil(WaterDepths(num3));
    int num21 = (int)ceil(WaterDepths(num5));
    int num22 = (int)ceil(WaterDepths(num7));
    int num23 = (int)ceil(WaterDepths(num9));
    int num24 = (int)ceil(WaterDepths(num11));
    int num25 = (int)ceil(WaterDepths(num13));
    int num26 = (int)ceil(WaterDepths(num15));
    float num27 = MAX8(
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num, num2 + num19, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num3, num4 + num20, originTerrainHeight, 1.414f, flag, flag2),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num5, num6 + num21, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num7, num8 + num22, originTerrainHeight, 1.414f, flag2, flag3),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num9, num10 + num23, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num11, num12 + num24, originTerrainHeight, 1.414f, flag3, flag4),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num13, num14 + num25, originTerrainHeight, 1),
        MoistureSpreadByMoistCell(LastTickMoistureLevelsBuff, num15, num16 + num26, originTerrainHeight, 1.414f, flag4, flag));
    float num28 = num17 - 0.5;
    if (num28 < 0)
    {
        num28 = 0;
    }
    float num29 = num28;
    if ((float)num18 > num28 && (float)num18 >= num27)
    {
        float num30 = num17 + 1;
        num29 = (((float)num18 > num30) ? num30 : ((float)num18));
    }
    else if (num27 > num28)
    {
        num29 = num27;
    }
    return num29 * (1 - Contaminations(index));
}

/************************************************************************/
/* Kernels                                                              */
/************************************************************************/
[numthreads(1024, 1, 1)]
void SavePreviousState(
    uint3 id : SV_DispatchThreadID,
    // Input.
    TMoistureLevelsBuff MoistureLevelsBuff,
    // Output.
    TRWLastTickMoistureLevelsBuff LastTickMoistureLevelsBuff)
{
    LastTickMoistureLevels(id.x) = MoistureLevels(id.x);
}

[numthreads(8, 8, 1)]
void CountWateredNeighbors(
    uint3 id : SV_DispatchThreadID,
    // Input.
    TWaterDepthsBuff WaterDepthsBuff,
    // Output.
    TRWWateredNeighboursBuff WateredNeighboursBuff)
{
    const uint index = CoordinatesToIndex(id.xy);
    int count = 0;
    if (WaterDepths(index) > 0) {
        count++;
        int num = index - Stride;
        int num2 = index - Stride - 1;
        int num3 = index - 1;
        int num4 = index + Stride - 1;
        int num5 = index + Stride;
        int num6 = index + Stride + 1;
        int num7 = index + 1;
        int num8 = index - Stride + 1;
        count += WaterDepths(num) > 0 ? 1 : 0;
        count += WaterDepths(num2) > 0 ? 1 : 0;
        count += WaterDepths(num3) > 0 ? 1 : 0;
        count += WaterDepths(num4) > 0 ? 1 : 0;
        count += WaterDepths(num5) > 0 ? 1 : 0;
        count += WaterDepths(num6) > 0 ? 1 : 0;
        count += WaterDepths(num7) > 0 ? 1 : 0;
        count += WaterDepths(num8) > 0 ? 1 : 0;
    }
    WateredNeighbours(index) = count;
}

[numthreads(8, 8, 1)]
void CalculateClusterSaturationAndWaterEvaporation(
    uint3 id : SV_DispatchThreadID,
    // Input.
    TWaterDepthsBuff WaterDepthsBuff,
    TWateredNeighboursBuff WateredNeighboursBuff,
    // Output.
    TRWClusterSaturationBuff ClusterSaturationBuff,
    TRWWaterEvaporationModifierBuff WaterEvaporationModifierBuff)
{
    const uint index = CoordinatesToIndex(id.xy);
    if (!(WaterDepths(index) > 0)) {
        ClusterSaturation(index) = 0;
        WaterEvaporationModifier(index) = 1;
        return;
    }
    int num2 = index - Stride;
    int num3 = index - 1;
    int num4 = index + Stride;
    int num5 = index + 1;
    int num6 = WateredNeighbours(index);
    int num7 = WateredNeighbours(num2);
    int num8 = WateredNeighbours(num3);
    int num9 = WateredNeighbours(num4);
    int num10 = WateredNeighbours(num5);
    if (num7 > num6) {
        num6 = num7 - 1;
    }
    if (num8 > num6) {
        num6 = num8 - 1;
    }
    if (num9 > num6) {
        num6 = num9 - 1;
    }
    if (num10 > num6) {
        num6 = num10 - 1;
    }
    ClusterSaturation(index) = num6 > MaxClusterSaturation
        ? MaxClusterSaturation
        : num6;
    int num11 = 10 - num6;
    float modifier = QuadraticEvaporationCoefficient * num11 * num11
        + LinearQuadraticCoefficient * num11
        + ConstantQuadraticCoefficient;
    WaterEvaporationModifier(index) = modifier;
}

[numthreads(8, 8, 1)]
void CalculateMoisture(
    uint3 id : SV_DispatchThreadID,
    // Input.
    TPackedInput1 PackedInput1,
    TWaterDepthsBuff WaterDepthsBuff,
    TContaminationsBuff ContaminationsBuff,
    TLastTickMoistureLevelsBuff LastTickMoistureLevelsBuff,
    TClusterSaturationBuff ClusterSaturationBuff,
    // Output.
    TAMoistureLevelsChangedLastTickBuff MoistureLevelsChangedLastTickBuff,
    // References.
    TRWMoistureLevelsBuff MoistureLevelsBuff)
{
    const uint index = CoordinatesToIndex(id.xy);
    float oldLevel = MoistureLevels(index);
    float newLevel = GetUpdatedMoisture(
        PackedInput1, WaterDepthsBuff, ContaminationsBuff, LastTickMoistureLevelsBuff, ClusterSaturationBuff,
        index);
    if (WaterTowerIrrigated(index) && newLevel < WaterTowerIrrigatedLevel)
    {
        newLevel = WaterTowerIrrigatedLevel;
    }
    if (abs(oldLevel - newLevel) > MIN_LEVEL_CHANGE)
    {
        MoistureLevels(index) = newLevel;
        AppendMoistureLevelsChangedLastTick(index);
    }
}
